[
  {
    "id": "q-001",
    "title": "两数之和",
    "difficulty": "easy",
    "content": "给定一个整数数组 nums 和一个整数 target，返回两数之和等于 target 的索引。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。",
    "examples": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0,1]",
        "explanation": "因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。"
      },
      {
        "input": "nums = [3,2,4], target = 6",
        "output": "[1,2]",
        "explanation": "因为 nums[1] + nums[2] == 6 ，返回 [1, 2] 。"
      }
    ],
    "solution": "使用哈希表存储每个元素的值和索引。遍历数组，对于每个元素 nums[i]，检查 target - nums[i] 是否在哈希表中。如果在，返回当前索引和哈希表中的索引。时间复杂度 O(n)，空间复杂度 O(n)。",
    "tags": ["数组", "哈希表"]
  },
  {
    "id": "q-002",
    "title": "反转链表",
    "difficulty": "easy",
    "content": "给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。",
    "examples": [
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[5,4,3,2,1]"
      },
      {
        "input": "head = [1,2]",
        "output": "[2,1]"
      }
    ],
    "solution": "使用迭代法。维护 prev 和 curr 两个指针，每次将 curr.next 指向 prev，然后移动 prev 和 curr。时间复杂度 O(n)，空间复杂度 O(1)。",
    "tags": ["链表"]
  },
  {
    "id": "q-003",
    "title": "合并两个有序数组",
    "difficulty": "easy",
    "content": "给你两个按非递减顺序排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。\n\n请你合并 nums2 到 nums1 中，使 nums1 成为一个有序数组。",
    "examples": [
      {
        "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
        "output": "[1,2,2,3,5,6]"
      }
    ],
    "solution": "从后向前合并。使用三个指针，分别指向 nums1 的末尾、nums2 的末尾和合并后的末尾。从后向前比较并放置元素。时间复杂度 O(m+n)，空间复杂度 O(1)。",
    "tags": ["数组", "双指针"]
  },
  {
    "id": "q-004",
    "title": "有效的括号",
    "difficulty": "easy",
    "content": "给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。\n\n有效字符串需满足：\n1. 左括号必须用相同类型的右括号闭合。\n2. 左括号必须以正确的顺序闭合。",
    "examples": [
      {
        "input": "()",
        "output": "true"
      },
      {
        "input": "()[]{}",
        "output": "true"
      },
      {
        "input": "(]",
        "output": "false"
      }
    ],
    "solution": "使用栈。遍历字符串，遇到左括号入栈，遇到右括号检查栈顶是否为对应的左括号。最后检查栈是否为空。时间复杂度 O(n)，空间复杂度 O(n)。",
    "tags": ["栈", "字符串"]
  },
  {
    "id": "q-005",
    "title": "最长无重复子串",
    "difficulty": "medium",
    "content": "给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。",
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "因为无重复字符的最长子串是 \"abc\"，所以其长度为 3 。"
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "因为无重复字符的最长子串是 \"b\"，所以其长度为 1 。"
      }
    ],
    "solution": "使用滑动窗口。维护一个窗口 [left, right] 和一个字符集合。当遇到重复字符时，移动左指针直到窗口内没有重复字符。时间复杂度 O(n)，空间复杂度 O(min(m,n))，其中 m 是字符集大小。",
    "tags": ["字符串", "滑动窗口"]
  },
  {
    "id": "q-006",
    "title": "三数之和",
    "difficulty": "medium",
    "content": "给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。",
    "examples": [
      {
        "input": "nums = [-1,0,1,2,-1,-4]",
        "output": "[[-1,-1,2],[-1,0,1]]"
      }
    ],
    "solution": "先排序，然后固定一个数，使用双指针找另外两个数。注意去重。时间复杂度 O(n²)，空间复杂度 O(1)。",
    "tags": ["数组", "双指针"]
  },
  {
    "id": "q-007",
    "title": "反转链表 II",
    "difficulty": "medium",
    "content": "给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回反转后的链表。",
    "examples": [
      {
        "input": "head = [1,2,3,4,5], left = 2, right = 4",
        "output": "[1,4,3,2,5]"
      }
    ],
    "solution": "使用头插法。先找到要反转的区间，然后逐个将后面的节点插入到区间前面。时间复杂度 O(n)，空间复杂度 O(1)。",
    "tags": ["链表"]
  },
  {
    "id": "q-008",
    "title": "验证二叉搜索树",
    "difficulty": "medium",
    "content": "给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。\n\n有效二叉搜索树定义如下：\n- 节点的左子树只包含小于当前节点的数。\n- 节点的右子树只包含大于当前节点的数。\n- 所有左子树和右子树自身必须也是二叉搜索树。",
    "examples": [
      {
        "input": "root = [2,1,3]",
        "output": "true"
      },
      {
        "input": "root = [5,1,4,null,null,3,6]",
        "output": "false"
      }
    ],
    "solution": "中序遍历，检查是否为递增序列。或者递归验证每个节点的范围。时间复杂度 O(n)，空间复杂度 O(n)。",
    "tags": ["树", "二叉搜索树"]
  },
  {
    "id": "q-009",
    "title": "合并 K 个升序链表",
    "difficulty": "hard",
    "content": "给你一个链表数组，每个链表都已经按升序排列。\n\n请你将所有链表合并到一个升序链表中，返回合并后的链表。",
    "examples": [
      {
        "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
        "output": "[1,1,2,3,4,4,5,6]"
      }
    ],
    "solution": "使用优先队列（最小堆）。将所有链表的头节点放入堆中，每次取出最小的节点加入结果链表，然后将该节点的下一个节点放入堆。时间复杂度 O(nklogk)，空间复杂度 O(k)。",
    "tags": ["链表", "堆"]
  },
  {
    "id": "q-010",
    "title": "最长递增子序列",
    "difficulty": "medium",
    "content": "给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。\n\n子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。",
    "examples": [
      {
        "input": "nums = [10,9,2,5,3,7,101,18]",
        "output": "4",
        "explanation": "最长递增子序列是 [2,3,7,101]，长度为 4。"
      }
    ],
    "solution": "动态规划。dp[i] 表示以 nums[i] 结尾的最长递增子序列长度。对于每个 i，遍历所有 j < i，如果 nums[j] < nums[i]，则 dp[i] = max(dp[i], dp[j] + 1)。时间复杂度 O(n²)，空间复杂度 O(n)。或者使用二分查找优化到 O(nlogn)。",
    "tags": ["数组", "动态规划"]
  }
]
